### 出错记录

```erlang

in function  apply/3
    called as apply(db_event,get,2)
 in call from codedb:get/2 (../src/core/codedb/codedb.erl, line 28)
 in call from mod_mission_new:api_play_story/4 (../src/mod/mod_mission_new.erl, line 180)
 
 错误原因:参数不对
 Event = ?CODE_DB(event, EventId),
    正确格式
 Event = ?CODE_DB(event, [EventId]),
    
 
```

##### 检查模块名，检查方法名，检查参数



##### 模式匹配时注意变量是否已经绑定



##### 通知被调用，更新协议



##### 记录错误，重新生成



##### 记录不匹配，检查模式匹配，检查是否数据格式不对,比如写错记录名

online worker error:
    player_id => 1000000121
    mod       => mod_player
    func      => do_login
    args      => [1000000121,"192.168.0.125"]
    reason    => {badrecord,player_maze_plot_data}
    stack     => [{database_curd,do,1,
                      [{file,"../src/core/database/database_curd.erl"},
                       {line,494}]},
                  {online_worker_srv,handle_apply,4,
                      [{file,"../src/core/online/online_worker_srv.erl"},
                       {line,110}]},
                  {online_worker_srv,handle_call,3,
                      [{file,"../src/core/online/online_worker_srv.erl"},
                       {line,165}]},
                  {gen_server2,handle_msg,2,
                      [{file,"../src/core/gen_server2/gen_server2.erl"},
                       {line,1096}]},
                  {proc_lib,init_p_do_apply,3,
                      [{file,"proc_lib.erl"},{line,249}]}]

### badarg

这个错误很好理解，参数类型错误，传入函数的参数和函数声明要求的参数类型不匹配。

### badarith

arith，atithmetic的简写，运算错误，例如将一个整数和一个atom相加。

### {badmatch, V}

模式匹配错误

### function_clause

从字面意思上看，是函数条款的错误。该错误信息表示找不到匹配的函数。例如，定义一个函数test:add/2，接收两个整数，并返回它们的和。如果传入小数，将找不到匹配的分支，会抛出function_clause。

### {case_clause, V}

case表达式找不到匹配的分支。一般要把“_”加到最后的分支中，作为容错或者其它。

### if_clause

Erlang中if表达式是case表达式的一种特殊方式，要求至少有一个分支测试条件的结果为true，否则会引发错误。

### undef

调用未定义的函数或者模块时，返回该错误信息。

### noproc

进程不存在，例如gen_server:call一个不存在的进程。

Pid = pid(0, 100, 10).
gen_server:call(Pid, test).
** exception exit: {noproc,{gen_server,call,[<0.100.10>,test]}}
in function gen_server:call/2 (gen_server.erl, line 182)

### system_limit

超出系统上限，如atom，ets，port，process等。

## 异常处理

在开发中可使用try,catch捕获异常，同时也可以调用erlang:get_stacktrace()获取栈信息，定位错误。

try:
exprs
catch
Class:Reason ->
%% 异常处理代码
%% Class为异常类型，Reason为异常原因
ok
end.

例如：

try:
whatever
catch
Class:Reason ->
io:format("Class:~p, Reason:~p~nstacktrace:~n~p",
[Class, Reason, erlang:get_stacktrace()]),
error
end.

##### exception error: no match of right hand side value [] 可能是返回值无法正确匹配

**1.启动节点如果想用全名启动，用－name的话直接写：**

\```erlang

erl -name gandalf -setcookie abc

\```

会报错："Can't set long node name!\nPlease check your configuration\n"

 

查看了erlang的邮件列表，大概的意思是用简称的话只能用－sname，用－name的话必须要写成 name@host的形式。

\```erlang

erl -name gandalf@localhost -setcookie abc

\```

**2.如果用与分布式erlang的话，启动时最好是写成如下方式：**

\```shell

erl -name server@192.168.0.149 -setcookie abc

\```

这样的话如果有其他节点访问的话直接写

\```erlang

net_adm:ping('server@192.168.0.149').

\```

就好，如果@后面不跟IP直接跟主机名称的话，有些路由会不识别，导致链接失败的情况，总之一句话，只要在shell里能ping通的名字，都可以写在@后面。

**3.启动erlang虚拟机的命令最好不要带着setcookie，否则任何人登录这台机器通过'ps -ef | grep erlang'命令都能查看到你set的cookie。**

**4.在module中如果使用了spawn，那么他的参数必须出现在此module的export列表中。**

**5.字符串转数字：**

list_to_integer(“99484")

string:to_integer(“12+18”)

数字转字符串：

integer_to_list(123123)

 

**6.字符串拼接：**

io:format(“~p”, [])

A ++ B 等于 string:connect(A,B)

lists:flatten(io_lib:format("Out of range! ~p is bigger than ~p.~n", [N, K])).

 

 

**7.创建ets表的进程挂了，ets表也会被销毁。同样创建tcp套接字的进程挂了，tcp套接字也会被销毁。**

 

**8.当前载入的所有module：**

code:all_loaded()

 

**9.同步多节点的代码：**

nl(Mod)